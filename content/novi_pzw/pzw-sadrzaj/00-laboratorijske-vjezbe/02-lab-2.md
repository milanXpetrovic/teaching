Odličan zadatak! Ovo je savršen primjer laboratorijske vježbe jer spaja nekoliko ključnih koncepata: generičke viewove, URL routing, rad s templateima i, što je najvažnije, filtriranje podataka na temelju relacija.

Prvo ću analizirati i poboljšati zadatak, a zatim ću generirati opširne pripremne materijale za studente, s linkovima na poglavlja koja smo već stvorili.

---

### Analiza i Poboljšanje Zadatka

Zadatak je dobar, ali ga možemo učiniti jasnijim, realističnijim i malo izazovnijim.

**Originalni problemi:**
1.  **Nedefinirani modeli:** Zadatak pretpostavlja da modeli `Sladoled` i `Sladoledni_kup` postoje, ali ne definira njihovu strukturu, što može dovesti do konfuzije. Ključna je relacija između njih.
2.  **Nejasnoća u prikazu:** "Prikažite sve atribute" je tehnički moguće, ali u praksi se prikazuju samo najvažniji atributi. Bolje je specificirati koje.
3.  **URL putanje:** Putanje poput `/sladoledi` su u redu, ali nedostaje korak gdje se aplikacijski URL-ovi uključuju u glavne, npr. pod prefiksom `shop/`.
4.  **Kopirana greška:** U drugom primjeru zadatka, očito je greška kod kopiranja gdje `napitci` vode na prikaz sladoleda.

**Prijedlog Poboljšanog Zadatka:**

---

**Laboratorijska vježba 2: Prikaz i Filtriranje Podataka**

**Predznanje:** U `models.py` vaše aplikacije definirani su sljedeći modeli. Pobrinite se da ste napravili i primijenili migracije te unijeli nekoliko primjera sladoleda i sladolednih kupova putem admin sučelja.

    class Sladoled(models.Model):
        naziv = models.CharField(max_length=100)
        vrsta = models.CharField(max_length=50) # npr. 'mliječni', 'voćni'
        opis = models.TextField()
        cijena_kuglice = models.DecimalField(max_digits=5, decimal_places=2)

        def __str__(self):
            return self.naziv

    class SladoledniKup(models.Model):
        naziv = models.CharField(max_length=150)
        opis = models.TextField()
        cijena = models.DecimalField(max_digits=6, decimal_places=2)
        sladoledi = models.ManyToManyField(Sladoled) # Jedan kup može imati više vrsta sladoleda

        def __str__(self):
            return self.naziv

---
**Zadatak 1: Generički Prikaz Liste**

Kreirajte generičke poglede (`ListView`) za modele `Sladoled` i `SladoledniKup`.

*   Na URL putanji `/slasticarna/sladoledi/` prikažite listu svih sladoleda. Za svaki sladoled, prikažite njegov **naziv** i **cijenu kuglice**.
*   Na URL putanji `/slasticarna/kupovi/` prikažite listu svih sladolednih kupova. Za svaki kup, prikažite njegov **naziv** i **cijenu**.

**Zadatak 2: Dinamičko Filtriranje na Temelju Relacije**

U prikazu liste sladoleda (Zadatak 1), svaki naziv sladoleda treba biti link. Klikom na taj link, korisnik treba biti odveden na novu stranicu koja prikazuje **samo one sladoledne kupove koji sadrže odabranu vrstu sladoleda**.

*   URL putanja za filtrirani prikaz neka slijedi format `/slasticarna/sladoledi/<int:pk_sladoleda>/kupovi/`.
*   Na stranici s filtriranim kupovima, prikažite prigodan naslov, npr. "Kupovi koji sadrže sladoled: [Naziv Sladoleda]".

**Bonus Zadatak:**
Na stranici s detaljima jednog sladolednog kupa (koju ćete morati sami napraviti koristeći `DetailView`), ispod opisa kupa, ispišite listu svih vrsta sladoleda koje taj kup sadrži.

---

### Pripremni Materijali za Laboratorijsku Vježbu 2

















---
parent: 'Laboratorijske Vježbe'
nav_order: 2
title: 'Priprema za Labos 2: Generički Viewovi i Filtriranje'
---

# Priprema za Labos 2: Generički Viewovi i Filtriranje

**Cilj vježbe:** U ovom laboratoriju primijenit ćemo znanje o generičkim klasnim viewovima (`Class-Based Views`) za prikazivanje podataka iz baze. Naučit ćemo kako koristiti `ListView` za prikaz listi objekata, kako povezati te viewove s URL-ovima i, što je najvažnije, kako stvoriti dinamičke stranice koje filtriraju podatke na temelju relacija među modelima.

Prije početka vježbe, ključno je da se prisjetite i razumijete sljedeće koncepte. Prođite kroz linkove ako niste sigurni u neki od njih.

## Ključni Koncepti za Ovu Vježbu

### 1. Generički `ListView`
Ovo je temeljni alat za ovu vježbu. `ListView` je Djangov ugrađeni klasni view koji drastično pojednostavljuje prikaz liste objekata iz baze. Umjesto da ručno dohvaćate sve objekte, `ListView` to radi za vas.

**Što morate znati:**
*   Kako kreirati klasu koja nasljeđuje `ListView`.
*   Koja su tri ključna atributa: `model`, `template_name` i `context_object_name`.

    **Ponavljanje gradiva:** [Poglavlje 4.4: Generički Klasni bazirani Viewovi (CBV)](/03-mvt-moduli/02-url-i-viewovi.md#44-generički-klasni-bazirani-viewovi-cbv)

### 2. URL Routing i `urls.py`
Svaki view koji kreirate mora biti dostupan putem jedinstvene URL adrese. Morate znati kako definirati putanje u `urls.py` datoteci vaše aplikacije i kako ih povezati s vašim viewovima.

**Što morate znati:**
*   Sintaksu `path()` funkcije.
*   Kako importati viewove i koristiti `.as_view()` metodu za CBV-ove.
*   Važnost `name` argumenta za reverzno razrješavanje URL-ova.

    **Ponavljanje gradiva:** [Poglavlje 4.1: URL Routing: Djangov prometnik](/03-mvt-moduli/02-url-i-viewovi.md#41-url-routing-djangov-prometnik)

### 3. Django Template Language (DTL)
Jednom kada `ListView` pošalje listu objekata u template, morate znati kako tu listu prikazati.

**Što morate znati:**
*   Kako proći kroz listu objekata koristeći `{% for ... %}` petlju.
*   Kako pristupiti atributima pojedinog objekta unutar petlje (npr. `{{ sladoled.naziv }}`).
*   Kako kreirati linkove koristeći `{% url 'ime-putanje' %}` tag.

    **Ponavljanje gradiva:** [Poglavlje 5.1: Django Template Language (DTL)](/03-mvt-moduli/03-predlosci-statika.md#51-django-template-language-dtl)

### 4. Relacije među Modelima (`ManyToManyField`)
Zadatak 2 se u potpunosti oslanja na vaše razumijevanje relacija. Model `SladoledniKup` je povezan s modelom `Sladoled` preko `ManyToManyField`. To znači da jedan kup može sadržavati više sladoleda, a jedan sladoled može biti dio više kupova.

**Što morate znati:**
*   Kako `ManyToManyField` funkcionira.
*   Kako pristupiti povezanim objektima. Ako imate objekt `sladoled`, svim kupovima koji ga sadrže možete pristupiti putem `sladoled.sladolednikup_set.all()`.

    **Ponavljanje gradiva:** [Poglavlje 3.5: Relacije među Modelima](/03-mvt-moduli/01-modeli-i-baze.md#35-relacije-među-modelima)

### 5. Dinamički URL-ovi
Da biste mogli filtrirati kupove za *točno određeni* sladoled, morate nekako tu informaciju (npr. ID sladoleda) proslijediti vašem viewu. To se radi putem dinamičkih URL-ova.

**Što morate znati:**
*   Kako koristiti "hvatače" (path converters) poput `<int:pk>` u `path()` funkciji.
*   Kako view prima tu vrijednost kao argument.

    **Ponavljanje gradiva:** Ponovno pogledajte `path('<int:pk>/', ...)` u poglavlju 4.1.

### 6. Nadjačavanje Metoda u CBV-ovima (`get_queryset`)
Ovo je **ključna tehnika** za rješavanje Zadatka 2. `ListView` po defaultu dohvaća **sve** objekte iz modela (`Model.objects.all()`). Da biste prikazali samo filtrirane rezultate, morate nadjačati (`override`) metodu `get_queryset`.

**Konceptualni primjer:**

```python
    class MojFiltriraniListView(ListView):
        model = SladoledniKup
        # ... ostali atributi

        def get_queryset(self):
            # Prvo, dohvatimo ID sladoleda iz URL-a
            id_sladoleda_za_filtriranje = self.kwargs['pk_sladoleda']

            # Zatim, filtriramo kupove
            # Vrati samo one kupove čije polje 'sladoledi' sadrži sladoled s tim ID-om
            return SladoledniKup.objects.filter(sladoledi__id=id_sladoleda_za_filtriranje)
```

Ova metoda vam daje potpunu kontrolu nad time koji podaci će biti poslani u template.

---

## Smjernice za Rješavanje

* **Zadatak 1:** Ovo je "zagrijavanje". Trebate kreirati dva jednostavna `ListView`-a, dva templatea i dvije URL putanje. Fokusirajte se na ispravno postavljanje `model`, `template_name` i `context_object_name`.
* **Zadatak 2:**
    1.  Prvo razmislite o **URL-u**. Treba vam dinamički URL koji će prihvatiti ID sladoleda.
    2.  Zatim kreirajte **novi view**. To će opet biti `ListView`, ali će prikazivati `SladoledniKup` objekte.
    3.  U tom novom viewu, implementirajte `get_queryset` metodu. Unutar nje, dohvatite ID iz `self.kwargs` i koristite ga za filtriranje `SladoledniKup` modela. Djangov ORM "double underscore" (`__`) lookup (`filter(sladoledi__id=...)`) je vaš najbolji prijatelj ovdje.
    4.  Na kraju, vratite se u template `post_list.html` i pretvorite nazive sladoleda u linkove koristeći `{% url %}` tag, prosljeđujući `sladoled.pk` kao argument.

Sretno s rješavanjem!
